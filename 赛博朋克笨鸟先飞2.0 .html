<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>霓虹飞跃：夜之城 | Cyberpunk Flappy Dive 2.8</title>
    <!-- 字体引入 -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* =========================================
           功能说明：全局样式与基础重置
           ========================================= */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* 禁止移动端默认触摸行为 */
            user-select: none;
        }

        /* 游戏主容器 */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* =========================================
           功能说明：视觉特效层
           ========================================= */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            animation: scrollLines 10s linear infinite;
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 11;
        }

        /* UI 层容器 - 关键层级 */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: none; /* 默认穿透，子元素需设置 auto */
            text-align: center;
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
        }
        
        #game-over-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            width: 100%;
            pointer-events: auto;
            padding-bottom: 20px;
        }

        /* =========================================
           功能说明：配置菜单样式
           ========================================= */
        #pause-screen {
            display: none;
            pointer-events: auto;
            background: rgba(0, 10, 20, 0.95);
            border: 2px solid #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2), inset 0 0 30px rgba(0, 255, 255, 0.1);
            padding: 25px;
            width: 85%;
            max-width: 550px;
            max-height: 90vh;
            overflow-y: auto;
            flex-direction: column;
            gap: 15px;
            backdrop-filter: blur(10px);
            text-align: left;
        }
        
        #pause-screen::-webkit-scrollbar {
            width: 6px;
        }
        #pause-screen::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.5); 
        }
        #pause-screen::-webkit-scrollbar-thumb {
            background: #0ff; 
            border-radius: 3px;
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 8px;
        }
        
        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .config-label {
            font-size: 0.85rem;
            color: #0ff;
            display: flex;
            justify-content: space-between;
        }

        .config-value {
            color: #fff;
            font-weight: bold;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 0 10px #fff;
            cursor: pointer;
            margin-top: -6px;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #005555;
            border-radius: 2px;
        }

        input[type=range]:focus::-webkit-slider-runnable-track {
            background: #0ff;
        }
        
        .cyber-checkbox {
            appearance: none;
            background-color: transparent;
            margin: 0;
            font: inherit;
            color: currentColor;
            width: 1.5em;
            height: 1.5em;
            border: 2px solid #0ff;
            display: grid;
            place-content: center;
            cursor: pointer;
            box-shadow: 0 0 5px #0ff;
        }
        
        .cyber-checkbox::before {
            content: "";
            width: 0.8em;
            height: 0.8em;
            transform: scale(0);
            transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em #0ff;
        }
        
        .cyber-checkbox:checked::before {
            transform: scale(1);
        }

        .config-section-title {
            color: #f0f;
            font-size: 1rem;
            border-bottom: 1px solid #f0f;
            margin-bottom: 10px;
            padding-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 10px;
        }

        /* =========================================
           功能说明：文字动画特效
           ========================================= */
        .glitch-text {
            font-size: 4rem;
            font-weight: 900;
            position: relative;
            animation: glitch 1s infinite;
        }

        .glitch-rainbow-text {
            font-size: 4rem;
            font-weight: 900;
            position: relative;
            animation: glitch 1s infinite, text-rainbow-cycle 5s linear infinite reverse;
        }

        .sub-text {
            font-size: 1.2rem;
            margin-top: 20px;
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
            animation: pulse 2s infinite;
        }

        @keyframes rainbow-cycle {
            0% { color: #ff0055; border-color: #ff0055; text-shadow: 0 0 10px #ff0055; box-shadow: 0 0 10px rgba(255, 0, 85, 0.3); }
            16% { color: #ffaa00; border-color: #ffaa00; text-shadow: 0 0 10px #ffaa00; box-shadow: 0 0 10px rgba(255, 170, 0, 0.3); }
            32% { color: #ffff00; border-color: #ffff00; text-shadow: 0 0 10px #ffff00; box-shadow: 0 0 10px rgba(255, 255, 0, 0.3); }
            48% { color: #00ff00; border-color: #00ff00; text-shadow: 0 0 10px #00ff00; box-shadow: 0 0 10px rgba(0, 255, 0, 0.3); }
            64% { color: #00ffff; border-color: #00ffff; text-shadow: 0 0 10px #00ffff; box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
            80% { color: #0000ff; border-color: #0000ff; text-shadow: 0 0 10px #0000ff; box-shadow: 0 0 10px rgba(0, 0, 255, 0.3); }
            96% { color: #ff00ff; border-color: #ff00ff; text-shadow: 0 0 10px #ff00ff; box-shadow: 0 0 10px rgba(255, 0, 255, 0.3); }
            100% { color: #ff0055; border-color: #ff0055; text-shadow: 0 0 10px #ff0055; box-shadow: 0 0 10px rgba(255, 0, 85, 0.3); }
        }

        @keyframes text-rainbow-cycle {
            0% { color: #ff0055; text-shadow: 0 0 20px #ff0055; }
            16% { color: #ffaa00; text-shadow: 0 0 20px #ffaa00; }
            32% { color: #ffff00; text-shadow: 0 0 20px #ffff00; }
            48% { color: #00ff00; text-shadow: 0 0 20px #00ff00; }
            64% { color: #00ffff; text-shadow: 0 0 20px #00ffff; }
            80% { color: #0000ff; text-shadow: 0 0 20px #0000ff; }
            96% { color: #ff00ff; text-shadow: 0 0 20px #ff00ff; }
            100% { color: #ff0055; text-shadow: 0 0 20px #ff0055; }
        }

        .rainbow-text {
            font-size: 2.5rem;
            font-weight: bold;
            animation: text-rainbow-cycle 3s linear infinite;
        }

        /* =========================================
           功能说明：HUD 界面 (分数、能量)
           ========================================= */
        .score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.8rem;
            font-weight: 700;
            z-index: 30;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid;
            border-left: 5px solid;
            padding: 5px 15px;
            letter-spacing: 2px;
            transition: transform 0.1s;
            animation: rainbow-cycle 4s linear infinite;
        }
        
        .score-glitch {
            animation: score-glitch-anim 0.2s infinite;
            filter: blur(1px);
            text-shadow: 2px 0 0 #ff00ff, -2px 0 0 #00ffff;
        }

        @keyframes score-glitch-anim {
            0% { transform: translate(1px, 1px); opacity: 0.9; }
            20% { transform: translate(-1px, 0); opacity: 0.85; }
            40% { transform: translate(0, 2px); opacity: 0.95; }
            60% { transform: translate(1px, -1px); opacity: 0.8; }
            80% { transform: translate(-2px, 0); opacity: 0.92; }
            100% { transform: translate(1px, 1px); opacity: 0.9; }
        }

        .score-active {
            transform: scale(1.1);
            filter: brightness(1.5);
        }

        .score-label {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.7);
            display: block;
            margin-bottom: -5px;
            letter-spacing: 1px;
        }
        
        .highscore-label {
            font-size: 0.7rem;
            color: #ffaa00;
            display: block;
            margin-top: 2px;
            letter-spacing: 1px;
        }

        .energy-bar-container {
            position: absolute;
            top: 130px; 
            left: 20px;
            width: 180px;
            height: 12px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #0ff;
            transform: skewX(-20deg);
            z-index: 30;
            pointer-events: none;
            display: none; 
        }

        .energy-bar-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #f0f, #0ff);
            transition: width 0.1s linear;
            box-shadow: 0 0 8px #f0f;
        }

        .energy-text {
            position: absolute;
            right: 5px;
            top: -16px;
            font-size: 0.7rem;
            color: #0ff;
            font-weight: bold;
            transform: skewX(20deg);
            text-shadow: 0 0 5px #000;
        }

        .fever-overlay-text {
            position: absolute;
            top: 30%;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 5rem;
            font-weight: 900;
            color: #ffff00;
            text-shadow: 5px 5px 0 #ff0055, -5px -5px 0 #00ffff;
            animation: fever-pulse 0.1s infinite;
            z-index: 50;
            pointer-events: none;
            display: none;
        }
        
        @keyframes fever-pulse {
            0% { transform: scale(1) skewX(-10deg); opacity: 1; }
            50% { transform: scale(1.1) skewX(10deg); opacity: 0.8; }
            100% { transform: scale(1) skewX(-10deg); opacity: 1; }
        }

        /* =========================================
           功能说明：交互按钮与控制
           ========================================= */
        .btn-prompt {
            padding: 15px 40px;
            border: 2px solid #0ff;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 15px #0ff;
            cursor: pointer;
            pointer-events: auto; /* 关键：强制接收点击 */
            transition: all 0.1s;
            position: relative;
            overflow: hidden;
        }

        .btn-prompt:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 40px #0ff, inset 0 0 10px #fff;
        }
        
        .btn-prompt:active {
            transform: scale(0.95);
        }
        
        .mode-select-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 12px 25px;
            font-size: 1rem;
            border: 1px solid #0ff;
            background: rgba(0, 20, 30, 0.8);
            color: #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            transition: all 0.2s;
            pointer-events: auto; /* 关键：修复开始按钮无法点击的问题 */
        }
        
        .mode-btn:hover {
            background: #0ff;
            color: #000;
            transform: translateY(-2px);
            box-shadow: 0 0 20px #0ff;
        }

        .btn-small {
            padding: 8px 20px;
            font-size: 0.9rem;
            border: 1px solid #f0f;
            color: #f0f;
            background: rgba(20, 0, 20, 0.8);
            box-shadow: 0 0 10px #f0f;
            pointer-events: auto;
        }
        .btn-small:hover {
            background: #f0f;
            color: #000;
        }

        .pause-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 19;
            display: none;
        }

        .settings-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border: 2px solid #0ff;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 30;
            pointer-events: auto;
            box-shadow: 0 0 10px #0ff;
            transition: all 0.2s;
            animation: pulse-border 2s infinite;
        }

        .settings-icon:hover {
            background: #0ff;
            box-shadow: 0 0 20px #0ff;
        }

        .settings-icon svg {
            width: 24px;
            height: 24px;
            stroke: #0ff;
            stroke-width: 2;
            fill: none;
            transition: stroke 0.2s;
        }

        .cyber-link {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem; 
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            text-decoration: none;
            pointer-events: auto;
            transition: all 0.3s;
            background: rgba(0, 20, 30, 0.8);
            padding: 5px 12px;
            border: 1px solid rgba(0,255,255,0.4);
            border-radius: 4px;
            z-index: 40;
            white-space: nowrap;
            letter-spacing: 1px;
        }
        
        .cyber-link:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 15px #0ff;
            text-shadow: none;
        }

        .dev-credit {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            color: rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
            z-index: 40;
            white-space: nowrap;
            pointer-events: none;
            font-weight: 300;
        }

        .breath-symbol {
            display: inline-block;
            color: #0ff;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
            animation: symbol-breathe 4s ease-in-out infinite;
        }

        @keyframes symbol-breathe {
            0%, 100% { opacity: 0.3; transform: scale(0.9); }
            50% { opacity: 0.8; transform: scale(1.1); text-shadow: 0 0 8px rgba(0, 255, 255, 0.8); }
        }

        .typewriter-text span {
            opacity: 0;
            color: #f0f;
            text-shadow: 0 0 2px rgba(255, 0, 255, 0.5);
            display: inline-block;
            animation: char-appear 8s linear infinite;
        }

        .typewriter-text span:nth-child(1) { animation-delay: 0s; }
        .typewriter-text span:nth-child(2) { animation-delay: 0.2s; }
        .typewriter-text span:nth-child(3) { animation-delay: 0.4s; }
        .typewriter-text span:nth-child(4) { animation-delay: 0.6s; }

        @keyframes char-appear {
            0% { opacity: 0; transform: translateY(2px); }
            5% { opacity: 1; transform: translateY(0); text-shadow: 0 0 8px #f0f; }
            10% { opacity: 0.9; text-shadow: 0 0 2px #f0f; }
            80% { opacity: 0.9; }
            85% { opacity: 0; }
            100% { opacity: 0; }
        }

        @keyframes pulse-border {
            0% { box-shadow: 0 0 5px #0ff; }
            50% { box-shadow: 0 0 15px #0ff; }
            100% { box-shadow: 0 0 5px #0ff; }
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        @keyframes glitch {
            0% { transform: translate(0) }
            20% { transform: translate(-2px, 2px) }
            40% { transform: translate(-2px, -2px) }
            60% { transform: translate(2px, 2px) }
            80% { transform: translate(2px, -2px) }
            100% { transform: translate(0) }
        }

        @keyframes scrollLines {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }
        
        .powerup-msg {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #fff;
            pointer-events: none;
            z-index: 25;
            animation: float-up 1s forwards;
        }
        
        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }
        
        .new-record-flash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #fff;
            z-index: 100;
            pointer-events: none;
            animation: flash-fade 0.5s forwards;
        }
        
        @keyframes flash-fade {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        @media (max-width: 600px) {
            .glitch-text, .glitch-rainbow-text { font-size: 2.5rem; }
            .score-display { font-size: 1.5rem; top: 10px; left: 10px; }
            .rainbow-text { font-size: 1.8rem; }
            #game-over-screen { gap: 20px; }
            #pause-screen { width: 95%; padding: 15px; max-height: 85vh; }
            .settings-icon { top: 10px; right: 10px; }
            .mode-select-container { flex-direction: column; gap: 15px; }
            
            .cyber-link { 
                top: 85px; 
                font-size: 0.65rem; 
                padding: 4px 8px; 
                max-width: 90%;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            } 
            
            .dev-credit { font-size: 0.8rem; bottom: 15px; }
            
            .energy-bar-container { top: 110px; left: 10px; width: 140px; } 
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- 核心游戏画布 -->
        <canvas id="gameCanvas"></canvas>
        
        <!-- 后期处理层 -->
        <div class="scanlines"></div>
        <div class="vignette"></div>
        <div id="pause-overlay" class="pause-overlay"></div>
        
        <!-- HUD: 分数与能量 -->
        <div id="score-container" class="score-display">
            <span class="score-label">SCORE_SYNC</span>
            <span id="score-val">000</span> 
            <span id="highscore-val" class="highscore-label">BEST: 000</span>
        </div>

        <div id="energy-bar" class="energy-bar-container">
            <div id="energy-fill" class="energy-bar-fill"></div>
            <span class="energy-text">ENERGY 0%</span>
        </div>

        <!-- 特效文字层 -->
        <div id="fever-overlay" class="fever-overlay-text">
            FEVER MODE
        </div>

        <!-- 设置按钮 -->
        <div id="settings-btn" class="settings-icon" onclick="togglePause()">
            <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
        </div>

        <!-- UI 交互层 -->
        <div id="ui-layer">
            <!-- 开始界面 -->
            <div id="start-screen">
                <a href="https://github.com/caozhaofeng/-Cyberpunk-Flappy-Dive" target="_blank" class="cyber-link">游戏主页:Cyberpunk-Flappy-Dive</a>

                <h1 class="glitch-rainbow-text" data-text="CYBER DIVE">CYBER DIVE</h1>
                
                <div id="mode-select-panel">
                    <p class="sub-text">选择操作模式启动引擎</p>
                    <div class="mode-select-container">
                        <button class="btn-prompt mode-btn" onclick="startWithMode('PC')">PC 终端 (PC MODE)</button>
                        <button class="btn-prompt mode-btn" onclick="startWithMode('MOBILE')">移动链路 (MOBILE MODE)</button>
                    </div>
                </div>

                <div id="start-prompt-panel" style="display: none;">
                    <p class="sub-text" style="margin-top: 20px;">点击屏幕或按空格起飞</p>
                    <div class="sub-text" style="font-size: 0.8rem; color: #0ff; margin-top:5px; animation: pulse 1s infinite;">SYSTEM READY</div>
                </div>

                <div class="sub-text" style="font-size: 0.8rem; color: #aaa; margin-top:15px;">物理引擎已校准 - 悬浮模式</div>
                <div class="sub-text" style="font-size: 0.7rem; color: #0ff; margin-top:5px;">[ESC] 或右上角图标 呼出系统配置</div>
                
                <div class="dev-credit">
                    —— <span class="breath-symbol">◇</span> 开发单元：<span class="typewriter-text"><span>逐</span><span>辰</span><span>十</span><span>七</span></span> <span class="breath-symbol">◇</span> ——
                </div>
            </div>

            <!-- 游戏结束界面 -->
            <div id="game-over-screen">
                <h1 class="glitch-text" style="color:#ff0055; text-shadow: 0 0 20px #ff0055;" data-text="SYSTEM FAILURE">SYSTEM FAILURE</h1>
                
                <div id="new-record-msg" style="display: none; color: #ffff00; font-weight: bold; font-size: 1.2rem; text-shadow: 0 0 10px #ff0000; animation: pulse 0.5s infinite;">
                    ★ NEW RECORD ★
                </div>

                <p id="final-score" class="rainbow-text">最终得分: 000</p>
                
                <button id="restart-btn" class="btn-prompt" onclick="returnToTitle()">重新连接系统</button>
            </div>

            <!-- 配置菜单 -->
            <div id="pause-screen">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: #0ff; font-size: 1.3rem; text-shadow: 0 0 10px #0ff;">SYSTEM CONFIG</h2>
                    <div style="font-size: 0.8rem; color: #f0f; animation: pulse 1s infinite;">// PAUSED //</div>
                </div>
                
                <!-- 功能开关区域 -->
                <div class="config-row" style="margin-top: 10px; border: 1px solid #0ff; padding: 10px; background: rgba(0, 255, 255, 0.1);">
                    <label class="config-label" style="font-size: 1rem; color: #fff;">无敌模式 GOD MODE</label>
                    <input type="checkbox" id="cfg-godMode" class="cyber-checkbox">
                </div>

                <!-- 连发模式开关 (新增) -->
                <div class="config-row" style="margin-top: 5px; border: 1px solid #ff0055; padding: 10px; background: rgba(255, 0, 85, 0.1);">
                    <label class="config-label" style="font-size: 1rem; color: #fff;">连发模式 RAPID FIRE</label>
                    <input type="checkbox" id="cfg-autoFire" class="cyber-checkbox">
                </div>
                
                <!-- 背景音乐开关 -->
                <div class="config-row" style="margin-top: 5px; border: 1px solid #f0f; padding: 10px; background: rgba(255, 0, 255, 0.1);">
                    <label class="config-label" style="font-size: 1rem; color: #fff;">背景音乐 BGM SYSTEM</label>
                    <input type="checkbox" id="cfg-bgm" class="cyber-checkbox">
                </div>

                <!-- 动力参数配置 -->
                <div class="config-section-title">DRONE DYNAMICS</div>
                
                <div class="config-group">
                    <label class="config-label">飞行坐标 X-AXIS <span id="val-playerX" class="config-value">80</span></label>
                    <input type="range" id="cfg-playerX" min="20" max="300" step="10" value="80">
                </div>

                <div class="config-group">
                    <label class="config-label">重力系数 GRAVITY <span id="val-gravity" class="config-value">0.15</span></label>
                    <input type="range" id="cfg-gravity" min="0.05" max="0.5" step="0.01" value="0.15">
                </div>

                <div class="config-group">
                    <label class="config-label">推进引擎 JUMP FORCE <span id="val-jump" class="config-value">4.0</span></label>
                    <input type="range" id="cfg-jump" min="2.0" max="8.0" step="0.1" value="4.0">
                </div>

                <!-- 环境参数配置 -->
                <div class="config-section-title">ENVIRONMENT</div>

                <div class="config-group">
                    <label class="config-label">当前速度 CURRENT SPEED <span id="val-gameSpeed" class="config-value">3.0</span></label>
                    <input type="range" id="cfg-gameSpeed" min="1.0" max="20.0" step="0.5" value="3.0">
                </div>

                <div class="config-group">
                    <label class="config-label">初始速率 INIT SPEED <span id="val-initSpeed" class="config-value">3.0</span></label>
                    <input type="range" id="cfg-initSpeed" min="1.0" max="10.0" step="0.5" value="3.0">
                </div>

                <div class="config-group">
                    <label class="config-label">加速幅度 ACCEL RATE <span id="val-accel" class="config-value">0.2</span></label>
                    <input type="range" id="cfg-accel" min="0.0" max="1.0" step="0.05" value="0.2">
                </div>

                <div class="config-group">
                    <label class="config-label">通道孔径 PIPE GAP <span id="val-gap" class="config-value">170</span></label>
                    <input type="range" id="cfg-gap" min="100" max="300" step="10" value="170">
                </div>
                
                <div class="config-group">
                    <label class="config-label">障碍间距 OBSTACLE DIST (PX) <span id="val-dist" class="config-value">360</span></label>
                    <input type="range" id="cfg-dist" min="200" max="800" step="10" value="360">
                </div>

                <!-- 暂停菜单底部按钮 -->
                <div style="display: flex; justify-content: space-between; margin-top: 15px;">
                    <button class="btn-prompt btn-small" onclick="resetConfig()">参数重置 FACTORY RESET</button>
                    <button class="btn-prompt btn-small" style="border-color: #0ff; color: #fff; background: rgba(0,255,255,0.2);" onclick="togglePause()">继续 RESUME</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =========================================
        // 功能说明：全局 DOM 元素引用与 Canvas 初始化
        // =========================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        // UI 元素引用
        const uiLayer = document.getElementById('ui-layer');
        const startScreen = document.getElementById('start-screen');
        const modeSelectPanel = document.getElementById('mode-select-panel');
        const startPromptPanel = document.getElementById('start-prompt-panel');
        const gameOverScreen = document.getElementById('game-over-screen');
        const newRecordMsg = document.getElementById('new-record-msg');
        const pauseScreen = document.getElementById('pause-screen');
        const pauseOverlay = document.getElementById('pause-overlay');
        const scoreContainer = document.getElementById('score-container');
        const scoreValEl = document.getElementById('score-val');
        const highscoreValEl = document.getElementById('highscore-val');
        const finalScoreEl = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');
        
        // 游戏状态 UI 引用
        const energyBarContainer = document.getElementById('energy-bar');
        const energyFill = document.getElementById('energy-fill');
        const feverOverlay = document.getElementById('fever-overlay');
        
        // =========================================
        // 功能说明：配色方案与视觉主题配置
        // =========================================
        const COLOR_SCHEMES = [
            { bg_dark: '#020205', bg_light: '#1a0b2e', grid_color: 'rgba(255, 0, 255, 0.3)', building1: '#0a0a20', building2: '#151530', building3: '#202040' },
            { bg_dark: '#010502', bg_light: '#0a1d1d', grid_color: 'rgba(0, 255, 0, 0.4)', building1: '#051505', building2: '#0a250a', building3: '#153015' },
            { bg_dark: '#0d0202', bg_light: '#300a0a', grid_color: 'rgba(255, 100, 0, 0.4)', building1: '#200505', building2: '#351005', building3: '#451505' },
            { bg_dark: '#010408', bg_light: '#0a1a2e', grid_color: 'rgba(100, 200, 255, 0.5)', building1: '#051020', building2: '#101530', building3: '#152045' },
            { bg_dark: '#10100a', bg_light: '#252010', grid_color: 'rgba(255, 255, 0, 0.3)', building1: '#202015', building2: '#303020', building3: '#404025' },
            { bg_dark: '#030303', bg_light: '#0f0f12', grid_color: 'rgba(255, 255, 255, 0.3)', building1: '#101015', building2: '#181018', building3: '#252530' },
            { bg_dark: '#0c0005', bg_light: '#300010', grid_color: 'rgba(255, 0, 85, 0.5)', building1: '#250510', building2: '#351015', building3: '#451520' },
            { bg_dark: '#00050a', bg_light: '#05202a', grid_color: 'rgba(0, 255, 150, 0.4)', building1: '#001010', building2: '#051520', building3: '#102030' },
            { bg_dark: '#000000', bg_light: '#101005', grid_color: 'rgba(255, 215, 0, 0.5)', building1: '#151505', building2: '#202010', building3: '#303015' },
            { bg_dark: '#000505', bg_light: '#0a2020', grid_color: 'rgba(0, 255, 255, 0.5)', building1: '#001010', building2: '#051515', building3: '#102525' },
            { bg_dark: '#0d0007', bg_light: '#300a20', grid_color: 'rgba(255, 105, 180, 0.5)', building1: '#200510', building2: '#351020', building3: '#451530' },
            { bg_dark: '#050205', bg_light: '#1a0d1a', grid_color: 'rgba(255, 255, 0, 0.5)', building1: '#100510', building2: '#181018', building3: '#201520' },
        ];
        
        let currentScheme = COLOR_SCHEMES[0];
        let schemeIndex = 0;
        let scoreColorChangeThreshold = 30; 
        const COLOR_CHANGE_STEP = 30;

        const neonColors = [
            '#ff0055', '#ffaa00', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ffffff', 
            '#39ff14', '#ff1493', '#9400d3', '#00ced1', '#ff4500', '#adff2f', '#ff69b4', '#1e90ff', 
            '#da70d6', '#FFD700', '#00FF7F', '#DC143C', '#8A2BE2', '#FF7F50', '#7FFF00', '#00BFFF', 
            '#FF00FF', '#F0E68C', '#E6E6FA', '#40E0D0', '#7DF9FF', '#FF6EFF', '#BFFF00', '#FF00CC', 
            '#00FFCA', '#FF9933', '#CCFF00', '#BF00FF', '#FE2400', '#2142FF', '#00FF9C'
        ];

        function getRandomNeonColor() {
            return neonColors[Math.floor(Math.random() * neonColors.length)];
        }

        // =========================================
        // 功能说明：数码酸雨环境特效系统
        // =========================================
        const rainSystem = {
            isActive: false,
            drops: [],
            obstaclesToLast: 0,
            
            start: function() {
                this.isActive = true;
                this.obstaclesToLast = 10; 
            },
            
            stop: function() {
                this.isActive = false;
            },
            
            update: function() {
                if (!this.isActive && Math.random() < 0.0005 && gameState === 'PLAYING') {
                    this.start();
                }
                
                if (this.isActive) {
                    const spawnRate = isFeverMode ? 8 : 4; 
                    for(let i=0; i<spawnRate; i++) {
                        this.drops.push(new RainDrop());
                    }
                }
                
                for (let i = this.drops.length - 1; i >= 0; i--) {
                    const drop = this.drops[i];
                    drop.update();
                    if (drop.markedForDeletion) {
                        this.drops.splice(i, 1);
                    }
                }
            },
            
            draw: function() {
                ctx.save();
                this.drops.forEach(drop => drop.draw());
                ctx.restore();
            },
            
            decrementCounter: function() {
                if (this.isActive) {
                    this.obstaclesToLast--;
                    if (this.obstaclesToLast <= 0) {
                        this.stop();
                    }
                }
            }
        };

        class RainDrop {
            constructor() {
                this.x = Math.random() * width;
                this.y = -50;
                this.length = Math.random() * 20 + 10;
                this.width = Math.random() * 1.5 + 0.5;
                this.speed = Math.random() * 10 + 15;
                this.color = getRandomNeonColor();
                this.markedForDeletion = false;
            }
            
            update() {
                this.y += this.speed;
                this.x -= gameSpeed * 0.2; 
                
                if (this.y > height) {
                    this.splash(this.y);
                    this.markedForDeletion = true;
                    return;
                }
                
                for(let ob of obstacles) {
                    if (this.x > ob.x && this.x < ob.x + pipeWidth) {
                        if (this.y > ob.bottomY && this.y < ob.bottomY + this.speed) {
                            this.splash(ob.bottomY);
                            this.markedForDeletion = true;
                            return;
                        }
                    }
                }
            }
            
            splash(yPos) {
                for(let i=0; i<3; i++) {
                    particles.push(new Particle(
                        this.x, 
                        yPos, 
                        this.color, 
                        3, 
                        Math.random() * 2 + 1, 
                        (Math.random() - 0.5) * 4, 
                        Math.random() * -3 - 2, 
                        0.1 
                    ));
                }
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.6;
                ctx.fillRect(this.x, this.y, this.width, this.length);
                ctx.globalAlpha = 1.0;
            }
        }
        
        // =========================================
        // 功能说明：环境装饰物 - 悬浮车实体
        // =========================================
        const hovercars = [];
        class Hovercar {
            constructor() {
                this.y = Math.random() * (height * 0.4) + 50; 
                this.x = width + 50;
                this.w = Math.random() * 80 + 40;
                this.h = Math.random() * 6 + 2;
                this.speed = Math.random() * 5 + 7;
                this.color = getRandomNeonColor();
                this.alpha = Math.random() * 0.4 + 0.3;
                this.markedForDeletion = false;
            }
            update() {
                this.x -= this.speed + gameSpeed * 0.5; 
                if (this.x + this.w < 0) this.markedForDeletion = true;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        
        // =========================================
        // 功能说明：输入处理逻辑与连发控制
        // =========================================
        let isInputHeld = false;
        let inputHoldInterval = null;
        const INPUT_REPEAT_RATE = 100; 
        
        function triggerJump() {
            if (gameState === 'PLAYING') {
                player.velocity = -player.jump; 
                player.changeColor(); 
                sound.jump();
                
                for(let i=0; i<5; i++) {
                    particles.push(new Particle(player.x - 10, player.y, player.currentTrailColor, 2));
                }
            }
        }

        function emitIntenseTrailParticles() {
            if (gameState === 'PLAYING' && isInputHeld && gameConfig.autoFire) {
                const particleCount = isFeverMode ? 10 : 8; 
                for (let i = 0; i < particleCount; i++) {
                    const color = getRandomNeonColor(); 
                    const vx = Math.random() * -3 - 1;
                    const vy = Math.random() * 2 - 1;
                    const size = Math.random() * 3 + 1;
                    particles.push(new Particle(player.x - 12, player.y, color, 4, size, vx, vy, 0.03));
                }
            }
        }

        // =========================================
        // 功能说明：游戏配置与默认参数定义
        // =========================================
        
        const pcConfig = {
            playerX: 80,
            gravity: 0.15,
            jumpForce: 4.0,
            initialSpeed: 3.0,
            speedIncrement: 0.2, 
            pipeGap: 180,
            obstacleDistance: 400,
            godMode: false,
            bgmEnabled: true,
            autoFire: true 
        };

        const mobileConfig = {
            playerX: 60,
            gravity: 0.12,
            jumpForce: 3.5,
            initialSpeed: 2.2,
            speedIncrement: 0.15,
            pipeGap: 200,
            obstacleDistance: 400,
            godMode: false,
            bgmEnabled: true,
            autoFire: false 
        };

        let gameConfig = { ...pcConfig };
        let currentMode = 'PC';
        let width, height;
        let frames = 0;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('cyber_highscore')) || 0;
        highscoreValEl.innerText = `BEST: ${highScore.toString().padStart(3, '0')}`;
        
        let gameState = 'MODE_SELECT'; 
        let lastGameState = 'MODE_SELECT';
        let gameSpeed = gameConfig.initialSpeed;
        let time = 0; 
        
        let shieldActive = false;
        let feverEnergy = 0;
        let isFeverMode = false;
        let feverTimer = 0;
        const MAX_FEVER_ENERGY = 100;
        const FEVER_DURATION = 300; 

        function changeColorScheme() {
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * COLOR_SCHEMES.length);
            } while (newIndex === schemeIndex && COLOR_SCHEMES.length > 1);
            
            schemeIndex = newIndex;
            currentScheme = COLOR_SCHEMES[schemeIndex];
            
            bgLayers[0].color = currentScheme.building1;
            bgLayers[1].color = currentScheme.building2;
            bgLayers[2].color = currentScheme.building3;
            
            scoreColorChangeThreshold = score + COLOR_CHANGE_STEP;
            
            for(let i=0; i<30; i++) {
                const color = getRandomNeonColor();
                particles.push(new Particle(width/2, height/2, color, 8));
            }
        }

        // =========================================
        // 功能说明：UI 绑定与配置管理
        // =========================================

        function startWithMode(mode) {
            currentMode = mode;
            if (mode === 'MOBILE') {
                gameConfig = { ...mobileConfig };
            } else {
                gameConfig = { ...pcConfig };
            }
            
            // 安全绑定配置，防止崩溃
            try {
                bindConfigUI();
            } catch (e) {
                console.error("Config binding failed:", e);
            }
            
            gameState = 'START';
            modeSelectPanel.style.display = 'none';
            startPromptPanel.style.display = 'block';
            player.reset();
            
            changeColorScheme(); 
            scoreColorChangeThreshold = 30; 
        }

        function bindConfigUI() {
            const bindRange = (id, key) => {
                const el = document.getElementById(id);
                if (!el) return; // 安全检查
                
                const valEl = document.getElementById('val-' + id.split('-')[1]);
                el.value = gameConfig[key];
                if (valEl) valEl.innerText = gameConfig[key];
                
                el.oninput = (e) => {
                    const val = parseFloat(e.target.value);
                    gameConfig[key] = val;
                    if (valEl) valEl.innerText = val;
                    if (key === 'playerX') player.x = val;
                    if (key === 'gravity') player.gravity = val; 
                    if (key === 'jumpForce') player.jump = val;
                };
            };
            
            const bindCheck = (id, key) => {
                const el = document.getElementById(id);
                if (!el) return; // 安全检查
                
                el.checked = gameConfig[key];
                el.onchange = (e) => {
                    gameConfig[key] = e.target.checked;
                    if (key === 'bgmEnabled') {
                        if (e.target.checked) synthWaveGen.start();
                        else synthWaveGen.stop();
                    }
                };
            };
            
            const bindRealtimeSpeed = () => {
                 const el = document.getElementById('cfg-gameSpeed');
                 const valEl = document.getElementById('val-gameSpeed');
                 if (!el) return; // 安全检查
                 
                 el.value = gameSpeed;
                 if (valEl) valEl.innerText = gameSpeed.toFixed(1);
                 el.oninput = (e) => {
                     const val = parseFloat(e.target.value);
                     gameSpeed = val; 
                     if (valEl) valEl.innerText = val.toFixed(1);
                 };
            };

            bindRange('cfg-playerX', 'playerX');
            bindRange('cfg-gravity', 'gravity');
            bindRange('cfg-jump', 'jumpForce');
            bindRange('cfg-initSpeed', 'initialSpeed');
            bindRange('cfg-accel', 'speedIncrement');
            bindRange('cfg-gap', 'pipeGap');
            bindRange('cfg-dist', 'obstacleDistance');
            bindCheck('cfg-godMode', 'godMode');
            bindCheck('cfg-bgm', 'bgmEnabled');
            bindCheck('cfg-autoFire', 'autoFire');
            bindRealtimeSpeed();
        }
        
        function resetConfig() {
            const wasBgmEnabled = gameConfig.bgmEnabled;
            if (currentMode === 'MOBILE') {
                gameConfig = { ...mobileConfig };
            } else {
                gameConfig = { ...pcConfig };
            }
            gameConfig.bgmEnabled = wasBgmEnabled;
            
            bindConfigUI();
            player.x = gameConfig.playerX;
            player.gravity = gameConfig.gravity;
            player.jump = gameConfig.jumpForce;

            sound.score(); 
        }

        function togglePause() {
            if (gameState === 'PAUSED') {
                gameState = lastGameState;
                pauseScreen.style.display = 'none';
                pauseOverlay.style.display = 'none';
                if (gameState === 'MODE_SELECT' || gameState === 'START') {
                    startScreen.style.display = 'block';
                } else if (gameState === 'GAMEOVER') {
                    gameOverScreen.style.display = 'flex';
                } else if (gameState === 'PLAYING') {
                    scoreContainer.style.display = 'block';
                    energyBarContainer.style.display = 'block'; 
                }
                if (gameConfig.bgmEnabled) synthWaveGen.setVolume(0.15);
            } else {
                lastGameState = gameState;
                gameState = 'PAUSED';
                const speedEl = document.getElementById('cfg-gameSpeed');
                const speedVal = document.getElementById('val-gameSpeed');
                if(speedEl) {
                    speedEl.value = gameSpeed;
                    speedVal.innerText = gameSpeed.toFixed(1);
                }
                pauseScreen.style.display = 'flex';
                pauseOverlay.style.display = 'block';
                startScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                scoreContainer.style.display = 'none'; 
                energyBarContainer.style.display = 'none';
                if (gameConfig.bgmEnabled) synthWaveGen.setVolume(0.05);
            }
        }

        // =========================================
        // 功能说明：音频系统 (合成器与音效)
        // =========================================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        const synthWaveGen = {
            osc: null,
            gain: null,
            filter: null,
            interval: null,
            noteIndex: 0,
            notes: [55, 55, 55, 55, 65.41, 65.41, 49, 49],
            isPlaying: false,

            start: function() {
                if (this.isPlaying) return;
                if (audioCtx.state === 'suspended') audioCtx.resume();
                
                this.osc = audioCtx.createOscillator();
                this.gain = audioCtx.createGain();
                this.filter = audioCtx.createBiquadFilter();

                this.osc.type = 'sawtooth';
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 400;
                this.filter.Q.value = 5;
                this.gain.gain.value = 0.15;

                this.osc.connect(this.filter);
                this.filter.connect(this.gain);
                this.gain.connect(audioCtx.destination);
                
                this.osc.start();
                this.isPlaying = true;

                const beatTime = 250; 
                this.interval = setInterval(() => {
                    if (gameState === 'PAUSED') return;
                    
                    const freq = this.notes[this.noteIndex % this.notes.length];
                    const multiplier = isFeverMode ? 1.5 : 1.0;
                    this.osc.frequency.setValueAtTime(freq * multiplier, audioCtx.currentTime);
                    
                    this.filter.frequency.setValueAtTime(800 * multiplier, audioCtx.currentTime);
                    this.filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.2);
                    
                    this.noteIndex++;
                }, isFeverMode ? 150 : beatTime); 
            },

            stop: function() {
                if (!this.isPlaying) return;
                if (this.osc) {
                    this.osc.stop();
                    this.osc.disconnect();
                }
                clearInterval(this.interval);
                this.isPlaying = false;
            },
            
            setVolume: function(val) {
                if (this.gain) {
                    this.gain.gain.setValueAtTime(val, audioCtx.currentTime);
                }
            }
        };

        const sound = {
            playTone: (freq, type, duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            jump: () => {
                const detune = Math.random() * 50;
                sound.playTone(120 + detune, 'sawtooth', 0.15, 0.15); 
            },
            score: () => {
                sound.playTone(880, 'sine', 0.1, 0.1);
                setTimeout(() => sound.playTone(1760, 'sine', 0.2, 0.1), 50);
            },
            powerUp: () => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            },
            feverStart: () => {
                sound.playTone(440, 'square', 0.5, 0.2);
                setTimeout(() => sound.playTone(880, 'square', 0.5, 0.2), 100);
                setTimeout(() => sound.playTone(1760, 'square', 1.0, 0.2), 200);
            },
            crash: () => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const bufferSize = audioCtx.sampleRate * 0.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                noise.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
            }
        };

        // =========================================
        // 功能说明：粒子系统与视觉特效
        // =========================================
        const particles = [];
        class Particle {
            constructor(x, y, color, speed, size, vxOverride, vyOverride, decaySpeed) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size || Math.random() * 3 + 1;
                
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * speed; 
                
                this.vx = vxOverride !== undefined ? vxOverride : Math.cos(angle) * velocity;
                this.vy = vyOverride !== undefined ? vyOverride : Math.sin(angle) * velocity;
                
                this.life = 1.0;
                this.decay = decaySpeed !== undefined ? decaySpeed : (Math.random() * 0.02 + 0.015); 
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.vy += 0.1; 
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.shadowBlur = 0; 
                ctx.globalAlpha = 1.0;
            }
        }
        
        // =========================================
        // 功能说明：道具系统 (奖励与护盾)
        // =========================================
        const powerUps = []; // 修复了 powerUps 未定义的问题
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'SHIELD', 'BONUS'
                this.markedForDeletion = false;
                this.oscillation = Math.random() * Math.PI * 2;
                
                this.size = 20;
                this.color = '#fff';

                if (this.type === 'BONUS') {
                     this.bonusValue = Math.floor(Math.random() * 5) + 1;
                     this.size = 28 - (this.bonusValue * 4);
                     this.color = '#FFD700'; // 金色
                } else if (this.type === 'SHIELD') {
                     this.size = 22; 
                     this.color = '#00FFFF'; // 青色
                }
            }
            
            update() {
                this.x -= gameSpeed; 
                this.oscillation += 0.1;
                this.y += Math.sin(this.oscillation) * 0.5; 
                
                if (isFeverMode && this.type === 'BONUS') {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    this.x += dx * 0.15; 
                    this.y += dy * 0.15;
                }

                if (this.x + this.size < 0) this.markedForDeletion = true;
                
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < player.radius + this.size/2) {
                    this.activate();
                    this.markedForDeletion = true;
                }
            }
            
            activate() {
                sound.powerUp();
                
                if (this.type === 'SHIELD') {
                    shieldActive = true;
                    showFloatingText("SHIELD UP", this.x, this.y, this.color);
                    addEnergy(20); 
                } else if (this.type === 'BONUS') {
                    score += this.bonusValue;
                    scoreValEl.innerText = score.toString().padStart(3, '0');
                    scoreContainer.classList.add('score-active');
                    setTimeout(() => scoreContainer.classList.remove('score-active'), 100);
                    showFloatingText(`+${this.bonusValue}`, this.x, this.y, this.color);
                    addEnergy(this.bonusValue * 3); 
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.oscillation); 
                
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                
                if (this.type === 'BONUS') {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'SHIELD') {
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                }
                
                ctx.restore();
            }
        }
        
        function showFloatingText(text, x, y, color) {
            const div = document.createElement('div');
            div.className = 'powerup-msg';
            div.innerText = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.style.color = color;
            div.style.textShadow = `0 0 10px ${color}`;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        // =========================================
        // 功能说明：背景图层与建筑生成
        // =========================================
        const bgLayers = [
            { speed: 0.5, buildings: [], color: '', yOffset: 100 },
            { speed: 1.5, buildings: [], color: '', yOffset: 50 },
            { speed: 3.0, buildings: [], color: '', yOffset: 0 } 
        ];

        function initBackground() {
            bgLayers[0].color = currentScheme.building1;
            bgLayers[1].color = currentScheme.building2;
            bgLayers[2].color = currentScheme.building3;
            
            bgLayers.forEach(layer => {
                layer.buildings = [];
                let currentX = 0;
                while (currentX < width + 200) {
                    const w = Math.random() * 50 + 30;
                    const h = Math.random() * (height / 2) + 50;
                    layer.buildings.push({ x: currentX, w: w, h: h });
                    currentX += w + Math.random() * 20 - 5; 
                }
            });
        }

        function updateBackground() {
            bgLayers.forEach(layer => {
                layer.buildings.forEach(b => {
                    const feverMult = isFeverMode ? 3.0 : 1.0; 
                    b.x -= layer.speed * (gameState === 'PLAYING' ? 1 : 0.2) * feverMult; 
                });

                if (layer.buildings[0].x + layer.buildings[0].w < 0) {
                    layer.buildings.shift();
                    const lastB = layer.buildings[layer.buildings.length - 1];
                    const w = Math.random() * 50 + 30;
                    const h = Math.random() * (height / 2) + 50;
                    layer.buildings.push({ x: lastB.x + lastB.w + Math.random() * 20 - 5, w: w, h: h });
                }
            });
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            
            if (isFeverMode) {
                const hue = (time * 500) % 360; 
                gradient.addColorStop(0, `hsl(${hue}, 100%, 20%)`);
                gradient.addColorStop(1, `hsl(${(hue + 180) % 360}, 100%, 50%)`);
                ctx.strokeStyle = `hsl(${(hue + 90) % 360}, 100%, 70%)`; 
            } else {
                gradient.addColorStop(0, currentScheme.bg_dark);
                gradient.addColorStop(1, currentScheme.bg_light);
                ctx.strokeStyle = currentScheme.grid_color;
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.lineWidth = 1;
            ctx.beginPath();
            const horizon = height * 0.8;
            
            for (let i = 0; i < width; i += 40) {
                const speedMult = isFeverMode ? 3 : 1;
                let x = (i - time * 20 * speedMult) % width;
                if(x < 0) x += width;
                ctx.moveTo(x, height);
                ctx.lineTo((x - width/2) * 0.2 + width/2, horizon); 
            }
            for(let i=0; i< (height - horizon); i+=20) {
                 let y = height - i;
                 ctx.moveTo(0, y);
                 ctx.lineTo(width, y);
            }
            ctx.stroke();
            ctx.restore();

            bgLayers.forEach((layer, index) => {
                if (isFeverMode) {
                    const hue = (time * 300 + index * 100) % 360; 
                    ctx.fillStyle = `hsla(${hue}, 80%, 40%, 0.8)`;
                } else {
                    ctx.fillStyle = layer.color;
                }
                
                layer.buildings.forEach(b => {
                    const renderY = height - b.h + layer.yOffset;
                    ctx.fillRect(b.x, renderY, b.w, b.h);
                    
                    if (index > 0) { 
                        ctx.globalAlpha = 0.5;
                        const seed = (b.x * b.w) % 100;
                        if (seed > 50) {
                            ctx.fillStyle = seed > 80 ? '#f0f' : '#0ff';
                            if (isFeverMode) ctx.fillStyle = '#fff'; 
                            ctx.fillRect(b.x + 5, renderY + 10, 4, 4);
                        }
                        ctx.globalAlpha = 1.0;
                        if (isFeverMode) {
                            const hue = (time * 300 + index * 100) % 360; 
                            ctx.fillStyle = `hsla(${hue}, 80%, 40%, 0.8)`;
                        } else {
                            ctx.fillStyle = layer.color;
                        }
                    }
                });
            });
        }

        // =========================================
        // 功能说明：玩家实体 (Drone) 逻辑
        // =========================================
        const player = {
            x: gameConfig.playerX,
            y: 150,
            radius: 12,
            velocity: 0,
            gravity: gameConfig.gravity, 
            jump: gameConfig.jumpForce,     
            maxFallSpeed: 8,
            rotation: 0,
            trail: [],
            currentTrailColor: '#00ffff', 
            shieldBreakingTimer: 0, 
            
            update: function() {
                this.velocity += this.gravity; 
                
                if (this.velocity > this.maxFallSpeed) {
                    this.velocity = this.maxFallSpeed;
                }

                this.y += this.velocity;

                if (this.y + this.radius >= height) {
                    this.y = height - this.radius;
                    setGameOver();
                }
                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocity = 0; 
                }

                let targetRotation = 0;
                if (this.velocity < 0) targetRotation = -0.3;
                else targetRotation = 0.3;
                
                this.rotation += (targetRotation - this.rotation) * 0.1;

                if (this.shieldBreakingTimer > 0) this.shieldBreakingTimer--;

                if (frames % 3 === 0 || isFeverMode) { 
                    this.trail.push({
                        x: this.x, 
                        y: this.y, 
                        alpha: 1,
                        color: this.currentTrailColor 
                    });
                    if (this.trail.length > 25) this.trail.shift(); 
                }
                this.trail.forEach(t => t.alpha -= 0.05);
            },

            draw: function() {
                ctx.save();
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                if (this.trail.length > 1) {
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const p1 = this.trail[i];
                        const p2 = this.trail[i+1];
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.strokeStyle = isFeverMode ? '#ffff00' : p1.color; 
                        ctx.globalAlpha = p1.alpha;
                        ctx.shadowBlur = isFeverMode ? 20 : 10;
                        ctx.shadowColor = ctx.strokeStyle;
                        ctx.stroke();
                    }
                }
                ctx.restore();

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (shieldActive) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 8, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + Math.sin(time*10)*0.2})`; 
                    ctx.lineWidth = 1; 
                    ctx.stroke();
                }
                
                if (gameConfig.godMode || isFeverMode) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 12, 0, Math.PI * 2);
                    ctx.strokeStyle = isFeverMode ? '#ffff00' : this.currentTrailColor; 
                    ctx.lineWidth = 4; 
                    ctx.stroke();
                }

                if (this.shieldBreakingTimer > 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 14, 0, Math.PI * 2);
                    const alpha = Math.abs(Math.sin(time * 30)); 
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    ctx.lineWidth = 5; 
                    ctx.stroke();
                }

                ctx.shadowBlur = 20;
                ctx.shadowColor = this.currentTrailColor; 
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(-10, 8);
                ctx.lineTo(-6, 0);
                ctx.lineTo(-10, -8);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = this.currentTrailColor; 
                ctx.shadowColor = this.currentTrailColor;
                ctx.beginPath();
                const flickr = Math.random() * 5;
                ctx.moveTo(-10, 0);
                ctx.lineTo(-18 - flickr, 4);
                ctx.lineTo(-18 - flickr, -4);
                ctx.fill();

                ctx.restore();
            },
            
            reset: function() {
                this.x = gameConfig.playerX;
                this.y = height / 2;
                this.velocity = 0;
                this.rotation = 0;
                this.trail = [];
                this.currentTrailColor = '#00ffff';
                this.gravity = gameConfig.gravity; 
                this.jump = gameConfig.jumpForce; 
                this.shieldBreakingTimer = 0;
            },
            
            changeColor: function() {
                let newColor;
                do {
                    newColor = getRandomNeonColor();
                } while(newColor === this.currentTrailColor);
                this.currentTrailColor = newColor;
            }
        };

        // =========================================
        // 功能说明：障碍物生成与管理
        // =========================================
        const obstacles = [];
        const pipeWidth = 60;
        
        class Obstacle {
            constructor(prevTopHeight) {
                this.x = width;
                
                const gap = gameConfig.pipeGap; 
                const minH = 50;
                const maxH = height - gap - 50;

                if (prevTopHeight !== undefined) {
                    const maxDiff = height / 2;
                    const low = Math.max(minH, prevTopHeight - maxDiff);
                    const high = Math.min(maxH, prevTopHeight + maxDiff);
                    this.topHeight = Math.random() * (high - low) + low;
                } else {
                    this.topHeight = Math.random() * (maxH - minH) + minH;
                }
                
                this.bottomY = this.topHeight + gap;
                this.passed = false;
                this.markedForDeletion = false;
                this.color = getRandomNeonColor();
                
                this.moving = score > 10; 
                this.moveSpeed = (Math.random() * 1 + 0.5) * (Math.random() > 0.5 ? 1 : -1);
                this.initialTop = this.topHeight;
            }

            update() {
                const feverMult = isFeverMode ? 3.0 : 1.0;
                this.x -= gameSpeed * feverMult;
                
                if (this.x + pipeWidth < 0) this.markedForDeletion = true;
                
                if (this.moving) {
                    this.topHeight += this.moveSpeed * feverMult;
                    if (Math.abs(this.topHeight - this.initialTop) > 60 || 
                        this.topHeight < 20 || 
                        this.bottomY > height - 20) {
                        this.moveSpeed *= -1;
                    }
                    this.bottomY = this.topHeight + gameConfig.pipeGap;
                }

                if (!gameConfig.godMode && !isFeverMode && player.shieldBreakingTimer <= 0) {
                    const padding = 6; 
                    
                    if (
                        player.x + player.radius - padding > this.x &&
                        player.x - player.radius + padding < this.x + pipeWidth &&
                        player.y - player.radius + padding < this.topHeight
                    ) {
                        handleCollision();
                    }

                    if (
                        player.x + player.radius - padding > this.x &&
                        player.x - player.radius + padding < this.x + pipeWidth &&
                        player.y + player.radius - padding > this.bottomY
                    ) {
                        handleCollision();
                    }
                }

                if (this.x + pipeWidth < player.x && !this.passed) {
                    score++;
                    scoreValEl.innerText = score.toString().padStart(3, '0');
                    scoreContainer.classList.add('score-active');
                    setTimeout(() => scoreContainer.classList.remove('score-active'), 100);
                    sound.score();
                    
                    addEnergy(1);
                    rainSystem.decrementCounter();

                    this.passed = true;
                    
                    if (score % 5 === 0 && gameSpeed < 10) {
                        gameSpeed += gameConfig.speedIncrement;
                    }
                }
            }

            draw() {
                ctx.shadowBlur = 15;
                ctx.shadowColor = isFeverMode ? '#00ff00' : this.color; 
                ctx.strokeStyle = isFeverMode ? '#00ff00' : this.color;
                ctx.lineWidth = 2;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                
                ctx.fillRect(this.x, 0, pipeWidth, this.topHeight);
                ctx.strokeRect(this.x, 0, pipeWidth, this.topHeight);
                ctx.fillRect(this.x, this.bottomY, pipeWidth, height - this.bottomY);
                ctx.strokeRect(this.x, this.bottomY, pipeWidth, height - this.bottomY);
                
                ctx.beginPath();
                ctx.moveTo(this.x + 10, 0);
                ctx.lineTo(this.x + 10, this.topHeight - 20);
                ctx.moveTo(this.x + pipeWidth - 10, this.bottomY + 20);
                ctx.lineTo(this.x + pipeWidth - 10, height);
                ctx.stroke();
                ctx.fillStyle = isFeverMode ? '#00ff00' : this.color;
                ctx.fillRect(this.x, this.topHeight - 10, pipeWidth, 10);
                ctx.fillRect(this.x, this.bottomY, pipeWidth, 10);
                ctx.shadowBlur = 0; 
            }
        }
        
        function handleCollision() {
            if (shieldActive) {
                shieldActive = false;
                player.shieldBreakingTimer = 60; 
                sound.powerUp(); 
                showFloatingText("SHIELD BREAK", player.x, player.y - 30, "#0ff");
            } else {
                setGameOver();
            }
        }
        
        // =========================================
        // 功能说明：能量系统 (Fever 模式)
        // =========================================
        function addEnergy(amount) {
            if (isFeverMode) return; 
            feverEnergy += amount;
            if (feverEnergy >= MAX_FEVER_ENERGY) {
                feverEnergy = MAX_FEVER_ENERGY;
                startFeverMode();
            }
            updateEnergyBar();
        }
        
        function updateEnergyBar() {
            const pct = Math.min(100, Math.floor((feverEnergy / MAX_FEVER_ENERGY) * 100));
            energyFill.style.width = `${pct}%`;
            const textEl = document.querySelector('.energy-text');
            
            if (isFeverMode) {
                energyFill.style.background = '#ffff00';
                energyFill.style.boxShadow = '0 0 15px #ffff00';
                textEl.innerText = "FEVER!!";
            } else {
                energyFill.style.background = 'linear-gradient(90deg, #f0f, #0ff)';
                energyFill.style.boxShadow = '0 0 8px #f0f';
                textEl.innerText = `ENERGY ${pct}%`;
            }
        }
        
        function startFeverMode() {
            isFeverMode = true;
            feverTimer = FEVER_DURATION;
            feverOverlay.style.display = 'block';
            sound.feverStart();
            
            if (gameConfig.bgmEnabled) {
                synthWaveGen.stop();
                synthWaveGen.start(); 
            }
        }
        
        function endFeverMode() {
            isFeverMode = false;
            feverEnergy = 0;
            player.shieldBreakingTimer = 120; 
            updateEnergyBar();
            feverOverlay.style.display = 'none';
            
            if (gameConfig.bgmEnabled) {
                synthWaveGen.stop();
                synthWaveGen.start();
            }
        }

        // =========================================
        // 功能说明：游戏核心流程控制
        // =========================================
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if(gameState === 'MODE_SELECT' || gameState === 'START') initBackground();
        }

        function returnToTitle() {
            gameState = 'START';
            
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'block';
            energyBarContainer.style.display = 'none';
            feverOverlay.style.display = 'none';
            
            modeSelectPanel.style.display = 'none';
            startPromptPanel.style.display = 'block';
            
            scoreContainer.style.display = 'block'; 
            scoreValEl.innerText = '000';
            newRecordMsg.style.display = 'none';
            
            player.reset();
            obstacles.length = 0;
            particles.length = 0;
            powerUps.length = 0;
            hovercars.length = 0; 
            score = 0;
            gameSpeed = gameConfig.initialSpeed;
            
            shieldActive = false;
            isFeverMode = false;
            feverEnergy = 0;
            
            rainSystem.stop();
            rainSystem.drops = [];

            changeColorScheme();
            scoreColorChangeThreshold = 30;
        }

        function resetGame() {
            player.reset();
            obstacles.length = 0;
            particles.length = 0;
            powerUps.length = 0;
            hovercars.length = 0; 
            score = 0;
            scoreValEl.innerText = '000'; 
            
            gameSpeed = gameConfig.initialSpeed;
            player.gravity = gameConfig.gravity;
            player.jump = gameConfig.jumpForce;
            
            frames = 0;
            
            shieldActive = false;
            isFeverMode = false;
            feverEnergy = 0;
            updateEnergyBar();
            
            rainSystem.stop();
            rainSystem.drops = [];
            
            gameState = 'PLAYING';
            
            // 确保UI可见
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            pauseOverlay.style.display = 'none';
            scoreContainer.style.display = 'block';
            energyBarContainer.style.display = 'block'; 
            newRecordMsg.style.display = 'none';
            feverOverlay.style.display = 'none';
            
            triggerJump();
            
            if (gameConfig.bgmEnabled) synthWaveGen.start();
            
            scoreColorChangeThreshold = COLOR_CHANGE_STEP; 
        }

        function setGameOver() {
            if (gameState === 'GAMEOVER') return;
            if (gameConfig.godMode || isFeverMode || player.shieldBreakingTimer > 0) return;

            gameState = 'GAMEOVER';
            sound.crash();
            synthWaveGen.stop();
            
            for(let i=0; i<100; i++) { 
                const color = getRandomNeonColor();
                const speed = Math.random() * 12 + 8; 
                const size = Math.random() * 5 + 2;
                particles.push(new Particle(player.x, player.y, color, speed, size));
            }
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('cyber_highscore', highScore);
                highscoreValEl.innerText = `BEST: ${highScore.toString().padStart(3, '0')}`;
                
                setTimeout(() => {
                    const flash = document.createElement('div');
                    flash.className = 'new-record-flash';
                    document.body.appendChild(flash);
                    setTimeout(() => flash.remove(), 500);
                    newRecordMsg.style.display = 'block';
                }, 500);
            }
            
            setTimeout(() => {
                finalScoreEl.innerText = `最终得分: ${score.toString().padStart(3, '0')}`;
                gameOverScreen.style.display = 'flex'; 
                energyBarContainer.style.display = 'none';
                feverOverlay.style.display = 'none';
            }, 500);
        }

        // =========================================
        // 功能说明：事件监听与输入分发
        // =========================================

        function handleInputDown(e) {
            // 忽略非游戏区域的点击 (UI按钮等)
            if (e.target.closest('#settings-btn') || 
                e.target.closest('button') || 
                e.target.closest('input') ||
                e.target.closest('.mode-btn') ||
                e.target.closest('.cyber-link') || 
                e.target.closest('#pause-screen')) {
                return;
            }

            if (e.type === 'touchstart' || e.type === 'mousedown') {
                 e.preventDefault(); 
            }
            
            if (gameState === 'PAUSED' || gameState === 'MODE_SELECT') return;

            // 键盘事件处理 (空格键)
            if (e.type === 'keydown' && e.code === 'Space') {
                 if (!e.repeat) { 
                    if (gameState === 'START') {
                        resetGame();
                    } else if (gameState === 'PLAYING') {
                        triggerJump();
                    }
                 }
                 return;
            }
            
            // 触摸/鼠标事件处理
            if (e.type === 'mousedown' || e.type === 'touchstart') {
                if (!isInputHeld) {
                    isInputHeld = true;

                    if (gameState === 'START') {
                        resetGame();
                        return;
                    }

                    if (gameState === 'PLAYING') {
                        triggerJump(); 
                        
                        if (gameConfig.autoFire) {
                            if (inputHoldInterval) clearInterval(inputHoldInterval);
                            inputHoldInterval = setInterval(() => {
                                if (isInputHeld && gameState === 'PLAYING') {
                                    triggerJump();
                                }
                            }, INPUT_REPEAT_RATE);
                        }
                    }
                }
            }
        }
        
        function handleInputUp(e) {
            if (e.type === 'keyup' && e.code === 'Space') return; 
            
            if (e.type === 'mouseup' || e.type === 'touchend') {
                isInputHeld = false;
                if (inputHoldInterval) {
                    clearInterval(inputHoldInterval);
                    inputHoldInterval = null;
                }
            }
        }
        
        function handleSpecialKeys(e) {
            if (e.code === 'Escape') {
                togglePause();
            }
        }

        // =========================================
        // 功能说明：游戏主循环
        // =========================================

        restartBtn.addEventListener('mousemove', (e) => {
             if (Math.random() > 0.5) return;
             const x = e.clientX;
             const y = e.clientY;
             for(let i=0; i<2; i++) {
                const color = getRandomNeonColor();
                particles.push(new Particle(x, y, color, 4, Math.random() * 3 + 1));
             }
        });

        function update() {
            if (gameState === 'PAUSED') return;

            time += 0.05;
            frames++;
            
            emitIntenseTrailParticles();
            
            if (isFeverMode) {
                feverTimer--;
                feverEnergy = (feverTimer / FEVER_DURATION) * MAX_FEVER_ENERGY;
                updateEnergyBar();
                if (feverTimer <= 0) {
                    endFeverMode();
                }
            }
            
            updateBackground();
            
            if (gameState === 'PLAYING') {
                const scoreDiff = scoreColorChangeThreshold - score;
                const scoreEl = document.getElementById('score-val');
                
                if (scoreDiff <= 10 && scoreDiff > 0 && !isFeverMode) {
                    scoreEl.classList.add('score-glitch');
                } else {
                    scoreEl.classList.remove('score-glitch');
                }
                
                if (score >= scoreColorChangeThreshold) {
                    changeColorScheme();
                }
                
                if (Math.random() < 0.005) hovercars.push(new Hovercar());
                
                rainSystem.update();
                player.update();
                
                const lastOb = obstacles.length > 0 ? obstacles[obstacles.length - 1] : null;
                const distMult = isFeverMode ? 1.5 : 1.0;
                
                if (!lastOb || (width - lastOb.x >= gameConfig.obstacleDistance * distMult)) {
                    const prevH = lastOb ? lastOb.topHeight : undefined;
                    obstacles.push(new Obstacle(prevH));
                    
                    if (Math.random() > 0.7) {
                        const rand = Math.random();
                        let type = rand < 0.90 ? 'BONUS' : 'SHIELD'; 
                        const py = (obstacles[obstacles.length-1].topHeight + obstacles[obstacles.length-1].bottomY) / 2;
                        powerUps.push(new PowerUp(width + 50, py, type));
                    }
                }

                obstacles.forEach((ob, index) => {
                    ob.update();
                    if (ob.markedForDeletion) obstacles.splice(index, 1);
                });
                
                powerUps.forEach((p, index) => {
                    p.update();
                    if (p.markedForDeletion) powerUps.splice(index, 1);
                });
                
                hovercars.forEach((c, index) => {
                    c.update();
                    if (c.markedForDeletion) hovercars.splice(index, 1);
                });
                
            } else if (gameState === 'GAMEOVER') {
                 if (player.y < height - player.radius) {
                     player.y += 10;
                     player.rotation += 0.2;
                 }
            } else if (gameState === 'START' || gameState === 'MODE_SELECT') {
                player.y = height / 2 + Math.sin(time * 2) * 20;
            }

            particles.forEach((p, index) => {
                p.update();
                if (p.life <= 0) particles.splice(index, 1);
            });
        }

        function draw() {
            if (gameState === 'PAUSED') return; 

            const bgAlpha = isFeverMode ? 0.3 : 0.6;
            ctx.fillStyle = `rgba(5, 5, 16, ${bgAlpha})`; 
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            
            if ((gameState === 'GAMEOVER' || isFeverMode) && Math.random() > 0.8) {
                const shake = isFeverMode ? 3 : 5;
                ctx.translate(Math.random()*shake - shake/2, Math.random()*shake - shake/2);
            }

            drawBackground();
            
            hovercars.forEach(c => c.draw()); 
            rainSystem.draw();
            obstacles.forEach(ob => ob.draw());
            powerUps.forEach(p => p.draw());
            particles.forEach(p => p.draw());
            player.draw();

            ctx.restore();
            
            if (Math.random() > 0.98 || gameState === 'GAMEOVER' || isFeverMode) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = isFeverMode ? 0.1 : 0.05; 
                ctx.drawImage(canvas, -5, 0); 
                ctx.drawImage(canvas, 5, 0);  
                ctx.restore();
            }
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        window.addEventListener('resize', resize);
        window.addEventListener('keydown', handleSpecialKeys); 
        window.addEventListener('keydown', handleInputDown);   
        window.addEventListener('keyup', handleInputUp);
        window.addEventListener('mousedown', handleInputDown);
        window.addEventListener('mouseup', handleInputUp);
        window.addEventListener('touchstart', handleInputDown, {passive: false});
        window.addEventListener('touchend', handleInputUp);
        window.addEventListener('contextmenu', (e) => { e.preventDefault(); }); 

        // 安全初始化
        try {
            bindConfigUI();
        } catch(e) { console.error("Init config failed:", e); }
        
        resize();
        initBackground();
        loop(); 

    </script>
</body>
</html>