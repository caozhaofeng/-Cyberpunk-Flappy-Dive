<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>霓虹飞跃：夜之城 | Cyberpunk Flappy Dive</title>
    <!-- 字体引入 -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* 禁止移动端默认触摸行为 */
        }

        /* 游戏容器 */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* 扫描线效果 */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            animation: scrollLines 10s linear infinite;
        }

        /* 暗角效果 */
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 11;
        }

        /* UI 层布局 */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: none; /* 点击穿透 */
            text-align: center;
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
        }
        
        /* 游戏结束界面 */
        #game-over-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            width: 100%;
        }

        /* 暂停/配置界面 */
        #pause-screen {
            display: none;
            pointer-events: auto;
            background: rgba(0, 10, 20, 0.95);
            border: 2px solid #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2), inset 0 0 30px rgba(0, 255, 255, 0.1);
            padding: 25px;
            width: 85%;
            max-width: 550px;
            max-height: 90vh;
            overflow-y: auto;
            flex-direction: column;
            gap: 15px;
            backdrop-filter: blur(10px);
            text-align: left;
        }
        
        /* 滚动条样式 */
        #pause-screen::-webkit-scrollbar {
            width: 6px;
        }
        #pause-screen::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.5); 
        }
        #pause-screen::-webkit-scrollbar-thumb {
            background: #0ff; 
            border-radius: 3px;
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 8px;
        }
        
        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .config-label {
            font-size: 0.85rem;
            color: #0ff;
            display: flex;
            justify-content: space-between;
        }

        .config-value {
            color: #fff;
            font-weight: bold;
        }

        /* 滑块样式 */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 0 10px #fff;
            cursor: pointer;
            margin-top: -6px;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #005555;
            border-radius: 2px;
        }

        input[type=range]:focus::-webkit-slider-runnable-track {
            background: #0ff;
        }
        
        /* 复选框样式 */
        .cyber-checkbox {
            appearance: none;
            background-color: transparent;
            margin: 0;
            font: inherit;
            color: currentColor;
            width: 1.5em;
            height: 1.5em;
            border: 2px solid #0ff;
            display: grid;
            place-content: center;
            cursor: pointer;
            box-shadow: 0 0 5px #0ff;
        }
        
        .cyber-checkbox::before {
            content: "";
            width: 0.8em;
            height: 0.8em;
            transform: scale(0);
            transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em #0ff;
        }
        
        .cyber-checkbox:checked::before {
            transform: scale(1);
        }

        .config-section-title {
            color: #f0f;
            font-size: 1rem;
            border-bottom: 1px solid #f0f;
            margin-bottom: 10px;
            padding-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 10px;
        }

        /* 故障文字效果 */
        .glitch-text {
            font-size: 4rem;
            font-weight: 900;
            position: relative;
            animation: glitch 1s infinite;
        }

        /* 标题文字效果 */
        .glitch-rainbow-text {
            font-size: 4rem;
            font-weight: 900;
            position: relative;
            animation: glitch 1s infinite, text-rainbow-cycle 5s linear infinite reverse;
        }

        .sub-text {
            font-size: 1.2rem;
            margin-top: 20px;
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
            animation: pulse 2s infinite;
        }

        /* 边框变色动画 */
        @keyframes rainbow-cycle {
            0% { color: #ff0055; border-color: #ff0055; text-shadow: 0 0 10px #ff0055; box-shadow: 0 0 10px rgba(255, 0, 85, 0.3); }
            16% { color: #ffaa00; border-color: #ffaa00; text-shadow: 0 0 10px #ffaa00; box-shadow: 0 0 10px rgba(255, 170, 0, 0.3); }
            32% { color: #ffff00; border-color: #ffff00; text-shadow: 0 0 10px #ffff00; box-shadow: 0 0 10px rgba(255, 255, 0, 0.3); }
            48% { color: #00ff00; border-color: #00ff00; text-shadow: 0 0 10px #00ff00; box-shadow: 0 0 10px rgba(0, 255, 0, 0.3); }
            64% { color: #00ffff; border-color: #00ffff; text-shadow: 0 0 10px #00ffff; box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
            80% { color: #0000ff; border-color: #0000ff; text-shadow: 0 0 10px #0000ff; box-shadow: 0 0 10px rgba(0, 0, 255, 0.3); }
            96% { color: #ff00ff; border-color: #ff00ff; text-shadow: 0 0 10px #ff00ff; box-shadow: 0 0 10px rgba(255, 0, 255, 0.3); }
            100% { color: #ff0055; border-color: #ff0055; text-shadow: 0 0 10px #ff0055; box-shadow: 0 0 10px rgba(255, 0, 85, 0.3); }
        }

        /* 纯文字变色动画 */
        @keyframes text-rainbow-cycle {
            0% { color: #ff0055; text-shadow: 0 0 20px #ff0055; }
            16% { color: #ffaa00; text-shadow: 0 0 20px #ffaa00; }
            32% { color: #ffff00; text-shadow: 0 0 20px #ffff00; }
            48% { color: #00ff00; text-shadow: 0 0 20px #00ff00; }
            64% { color: #00ffff; text-shadow: 0 0 20px #00ffff; }
            80% { color: #0000ff; text-shadow: 0 0 20px #0000ff; }
            96% { color: #ff00ff; text-shadow: 0 0 20px #ff00ff; }
            100% { color: #ff0055; text-shadow: 0 0 20px #ff0055; }
        }

        /* 变色文字类 */
        .rainbow-text {
            font-size: 2.5rem;
            font-weight: bold;
            animation: text-rainbow-cycle 3s linear infinite;
        }

        /* 计分板样式 */
        .score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.8rem;
            font-weight: 700;
            z-index: 30;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid;
            border-left: 5px solid;
            padding: 5px 15px;
            letter-spacing: 2px;
            transition: transform 0.1s;
            animation: rainbow-cycle 4s linear infinite;
        }

        .score-active {
            transform: scale(1.1);
            filter: brightness(1.5);
        }

        .score-label {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.7);
            display: block;
            margin-bottom: -5px;
            letter-spacing: 1px;
        }

        /* 按钮通用样式 */
        .btn-prompt {
            padding: 15px 40px;
            border: 2px solid #0ff;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 15px #0ff;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.1s;
            position: relative;
            overflow: hidden;
        }

        .btn-prompt:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 40px #0ff, inset 0 0 10px #fff;
        }
        
        .btn-prompt:active {
            transform: scale(0.95);
        }
        
        /* 模式选择容器 */
        .mode-select-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* 模式按钮样式 */
        .mode-btn {
            padding: 12px 25px;
            font-size: 1rem;
            border: 1px solid #0ff;
            background: rgba(0, 20, 30, 0.8);
            color: #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            transition: all 0.2s;
        }
        
        .mode-btn:hover {
            background: #0ff;
            color: #000;
            transform: translateY(-2px);
            box-shadow: 0 0 20px #0ff;
        }

        /* 小号按钮样式 */
        .btn-small {
            padding: 8px 20px;
            font-size: 0.9rem;
            border: 1px solid #f0f;
            color: #f0f;
            background: rgba(20, 0, 20, 0.8);
            box-shadow: 0 0 10px #f0f;
        }
        .btn-small:hover {
            background: #f0f;
            color: #000;
        }

        .pause-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 19;
            display: none;
        }

        /* 设置图标样式 */
        .settings-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border: 2px solid #0ff;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 30;
            pointer-events: auto;
            box-shadow: 0 0 10px #0ff;
            transition: all 0.2s;
            animation: pulse-border 2s infinite;
        }

        .settings-icon:hover {
            background: #0ff;
            box-shadow: 0 0 20px #0ff;
        }

        .settings-icon:hover svg {
            stroke: #000;
        }

        .settings-icon svg {
            width: 24px;
            height: 24px;
            stroke: #0ff;
            stroke-width: 2;
            fill: none;
            transition: stroke 0.2s;
        }

        /* 顶部链接样式 */
        .cyber-link {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem; 
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            text-decoration: none;
            pointer-events: auto;
            transition: all 0.3s;
            background: rgba(0, 20, 30, 0.8);
            padding: 5px 12px;
            border: 1px solid rgba(0,255,255,0.4);
            border-radius: 4px;
            z-index: 40;
            white-space: nowrap;
            letter-spacing: 1px;
        }
        
        .cyber-link:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 15px #0ff;
            text-shadow: none;
        }

        /* 底部署名样式 */
        .dev-credit {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            color: rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
            z-index: 40;
            white-space: nowrap;
            pointer-events: none;
            font-weight: 300;
        }

        /* 符号呼吸效果 */
        .breath-symbol {
            display: inline-block;
            color: #0ff;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
            animation: symbol-breathe 4s ease-in-out infinite;
        }

        @keyframes symbol-breathe {
            0%, 100% { opacity: 0.3; transform: scale(0.9); }
            50% { opacity: 0.8; transform: scale(1.1); text-shadow: 0 0 8px rgba(0, 255, 255, 0.8); }
        }

        /* 逐字显示动画 */
        .typewriter-text span {
            opacity: 0;
            color: #f0f;
            text-shadow: 0 0 2px rgba(255, 0, 255, 0.5);
            display: inline-block;
            animation: char-appear 8s linear infinite;
        }

        .typewriter-text span:nth-child(1) { animation-delay: 0s; }
        .typewriter-text span:nth-child(2) { animation-delay: 0.2s; }
        .typewriter-text span:nth-child(3) { animation-delay: 0.4s; }
        .typewriter-text span:nth-child(4) { animation-delay: 0.6s; }

        @keyframes char-appear {
            0% { opacity: 0; transform: translateY(2px); }
            5% { opacity: 1; transform: translateY(0); text-shadow: 0 0 8px #f0f; }
            10% { opacity: 0.9; text-shadow: 0 0 2px #f0f; }
            80% { opacity: 0.9; }
            85% { opacity: 0; }
            100% { opacity: 0; }
        }

        /* 边框脉冲 */
        @keyframes pulse-border {
            0% { box-shadow: 0 0 5px #0ff; }
            50% { box-shadow: 0 0 15px #0ff; }
            100% { box-shadow: 0 0 5px #0ff; }
        }

        /* 透明度脉冲 */
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        /* 故障动画 */
        @keyframes glitch {
            0% { transform: translate(0) }
            20% { transform: translate(-2px, 2px) }
            40% { transform: translate(-2px, -2px) }
            60% { transform: translate(2px, 2px) }
            80% { transform: translate(2px, -2px) }
            100% { transform: translate(0) }
        }

        /* 扫描线动画 */
        @keyframes scrollLines {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        /* 移动端适配 */
        @media (max-width: 600px) {
            .glitch-text, .glitch-rainbow-text { font-size: 2.5rem; }
            .score-display { font-size: 1.5rem; top: 10px; left: 10px; }
            .rainbow-text { font-size: 1.8rem; }
            #game-over-screen { gap: 20px; }
            #pause-screen { width: 95%; padding: 15px; max-height: 85vh; }
            .settings-icon { top: 10px; right: 10px; }
            .mode-select-container { flex-direction: column; gap: 15px; }
            
            /* 移动端样式调整 */
            .cyber-link { 
                top: 85px; 
                font-size: 0.65rem; 
                padding: 4px 8px; 
                max-width: 90%;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            } 
            
            .dev-credit { font-size: 0.8rem; bottom: 15px; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>
        <div id="pause-overlay" class="pause-overlay"></div>
        
        <div id="score-container" class="score-display">
            <span class="score-label">SCORE_SYNC</span>
            <span id="score-val">000</span>
        </div>

        <!-- 设置图标 -->
        <div id="settings-btn" class="settings-icon" onclick="togglePause()">
            <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
        </div>

        <div id="ui-layer">
            <div id="start-screen">
                <!-- 个人主页链接 -->
                <a href="https://github.com/caozhaofeng" target="_blank" class="cyber-link">个人主页: https://github.com/caozhaofeng</a>

                <h1 class="glitch-rainbow-text" data-text="CYBER DIVE">CYBER DIVE</h1>
                
                <!-- 模式选择面板 -->
                <div id="mode-select-panel">
                    <p class="sub-text">选择操作模式启动引擎</p>
                    <div class="mode-select-container">
                        <button class="btn-prompt mode-btn" onclick="startWithMode('PC')">PC 终端 (PC MODE)</button>
                        <button class="btn-prompt mode-btn" onclick="startWithMode('MOBILE')">移动链路 (MOBILE MODE)</button>
                    </div>
                </div>

                <!-- 开始提示面板 -->
                <div id="start-prompt-panel" style="display: none;">
                    <p class="sub-text" style="margin-top: 20px;">点击屏幕或按空格起飞</p>
                    <div class="sub-text" style="font-size: 0.8rem; color: #0ff; margin-top:5px; animation: pulse 1s infinite;">SYSTEM READY</div>
                </div>

                <div class="sub-text" style="font-size: 0.8rem; color: #aaa; margin-top:15px;">物理引擎已校准 - 悬浮模式</div>
                <div class="sub-text" style="font-size: 0.7rem; color: #0ff; margin-top:5px;">[ESC] 或右上角图标 呼出系统配置</div>
                
                <!-- 开发人员署名 -->
                <div class="dev-credit">
                    —— <span class="breath-symbol">◇</span> 开发单元：<span class="typewriter-text"><span>逐</span><span>辰</span><span>十</span><span>七</span></span> <span class="breath-symbol">◇</span> ——
                </div>
            </div>

            <div id="game-over-screen">
                <h1 class="glitch-text" style="color:#ff0055; text-shadow: 0 0 20px #ff0055;" data-text="SYSTEM FAILURE">SYSTEM FAILURE</h1>
                <p id="final-score" class="rainbow-text">最终得分: 000</p>
                <!-- 返回标题按钮 -->
                <button id="restart-btn" class="btn-prompt" onclick="returnToTitle()">重新连接系统</button>
            </div>

            <!-- 配置菜单 -->
            <div id="pause-screen">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: #0ff; font-size: 1.3rem; text-shadow: 0 0 10px #0ff;">SYSTEM CONFIG</h2>
                    <div style="font-size: 0.8rem; color: #f0f; animation: pulse 1s infinite;">// PAUSED //</div>
                </div>
                
                <!-- 无敌模式开关 -->
                <div class="config-row" style="margin-top: 10px; border: 1px solid #0ff; padding: 10px; background: rgba(0, 255, 255, 0.1);">
                    <label class="config-label" style="font-size: 1rem; color: #fff;">无敌模式 GOD MODE</label>
                    <input type="checkbox" id="cfg-godMode" class="cyber-checkbox">
                </div>

                <!-- 动力学参数 -->
                <div class="config-section-title">DRONE DYNAMICS</div>
                
                <div class="config-group">
                    <label class="config-label">飞行坐标 X-AXIS <span id="val-playerX" class="config-value">80</span></label>
                    <input type="range" id="cfg-playerX" min="20" max="300" step="10" value="80">
                </div>

                <div class="config-group">
                    <label class="config-label">重力系数 GRAVITY <span id="val-gravity" class="config-value">0.15</span></label>
                    <input type="range" id="cfg-gravity" min="0.05" max="0.5" step="0.01" value="0.15">
                </div>

                <div class="config-group">
                    <label class="config-label">推进引擎 JUMP FORCE <span id="val-jump" class="config-value">4.0</span></label>
                    <input type="range" id="cfg-jump" min="2.0" max="8.0" step="0.1" value="4.0">
                </div>

                <!-- 环境参数 -->
                <div class="config-section-title">ENVIRONMENT</div>

                <div class="config-group">
                    <label class="config-label">当前速度 CURRENT SPEED <span id="val-gameSpeed" class="config-value">3.0</span></label>
                    <input type="range" id="cfg-gameSpeed" min="1.0" max="20.0" step="0.5" value="3.0">
                </div>

                <div class="config-group">
                    <label class="config-label">初始速率 INIT SPEED <span id="val-initSpeed" class="config-value">3.0</span></label>
                    <input type="range" id="cfg-initSpeed" min="1.0" max="10.0" step="0.5" value="3.0">
                </div>

                <div class="config-group">
                    <label class="config-label">加速幅度 ACCEL RATE <span id="val-accel" class="config-value">0.2</span></label>
                    <input type="range" id="cfg-accel" min="0.0" max="1.0" step="0.05" value="0.2">
                </div>

                <div class="config-group">
                    <label class="config-label">通道孔径 PIPE GAP <span id="val-gap" class="config-value">170</span></label>
                    <input type="range" id="cfg-gap" min="100" max="300" step="10" value="170">
                </div>
                
                <div class="config-group">
                    <label class="config-label">障碍间距 OBSTACLE DIST (PX) <span id="val-dist" class="config-value">360</span></label>
                    <input type="range" id="cfg-dist" min="200" max="800" step="10" value="360">
                </div>

                <div style="display: flex; justify-content: space-between; margin-top: 15px;">
                    <button class="btn-prompt btn-small" onclick="resetConfig()">参数重置 FACTORY RESET</button>
                    <button class="btn-prompt btn-small" style="border-color: #0ff; color: #fff; background: rgba(0,255,255,0.2);" onclick="togglePause()">继续 RESUME</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 系统变量 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const uiLayer = document.getElementById('ui-layer');
        const startScreen = document.getElementById('start-screen');
        const modeSelectPanel = document.getElementById('mode-select-panel');
        const startPromptPanel = document.getElementById('start-prompt-panel');
        const gameOverScreen = document.getElementById('game-over-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const pauseOverlay = document.getElementById('pause-overlay');
        const scoreContainer = document.getElementById('score-container');
        const scoreValEl = document.getElementById('score-val');
        const finalScoreEl = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');

        // --- 默认配置 (PC) ---
        const pcConfig = {
            playerX: 80,
            gravity: 0.15,
            jumpForce: 4.0,
            initialSpeed: 3.0,
            speedIncrement: 0.2, 
            pipeGap: 170,
            obstacleDistance: 360,
            godMode: false
        };

        // --- 移动端配置 (优化手感) ---
        const mobileConfig = {
            playerX: 60,
            gravity: 0.12,
            jumpForce: 3.5,
            initialSpeed: 2.2,
            speedIncrement: 0.15,
            pipeGap: 190,
            obstacleDistance: 400,
            godMode: false
        };

        // --- 全局配置 ---
        let gameConfig = { ...pcConfig };
        let currentMode = 'PC';

        let width, height;
        let frames = 0;
        let score = 0;
        let highScore = localStorage.getItem('cyber_highscore') || 0;
        
        // 游戏状态
        let gameState = 'MODE_SELECT'; 
        let lastGameState = 'MODE_SELECT';
        
        let gameSpeed = gameConfig.initialSpeed;
        let time = 0; 

        // 颜色配置
        const neonColors = [
            '#ff0055', '#ffaa00', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ffffff', 
            '#39ff14', '#ff1493', '#9400d3', '#00ced1', '#ff4500', '#adff2f', '#ff69b4', '#1e90ff', 
            '#da70d6', '#FFD700', '#00FF7F', '#DC143C', '#8A2BE2', '#FF7F50', '#7FFF00', '#00BFFF', 
            '#FF00FF', '#F0E68C', '#E6E6FA', '#40E0D0', '#7DF9FF', '#FF6EFF', '#BFFF00', '#FF00CC', 
            '#00FFCA', '#FF9933', '#CCFF00', '#BF00FF', '#FE2400', '#2142FF', '#00FF9C'
        ];

        function getRandomNeonColor() {
            return neonColors[Math.floor(Math.random() * neonColors.length)];
        }

        // --- 模式启动逻辑 ---
        function startWithMode(mode) {
            currentMode = mode;
            if (mode === 'MOBILE') {
                gameConfig = { ...mobileConfig };
            } else {
                gameConfig = { ...pcConfig };
            }
            bindConfigUI();
            gameState = 'START';
            modeSelectPanel.style.display = 'none';
            startPromptPanel.style.display = 'block';
            player.reset();
        }

        // --- 绑定配置 UI ---
        function bindConfigUI() {
            const bindRange = (id, key) => {
                const el = document.getElementById(id);
                const valEl = document.getElementById('val-' + id.split('-')[1]);
                el.value = gameConfig[key];
                valEl.innerText = gameConfig[key];
                
                el.oninput = (e) => {
                    const val = parseFloat(e.target.value);
                    gameConfig[key] = val;
                    valEl.innerText = val;
                    if (key === 'playerX') player.x = val;
                    if (key === 'gravity') player.gravity = val;
                    if (key === 'jumpForce') player.jump = val;
                };
            };
            
            const bindCheck = (id, key) => {
                const el = document.getElementById(id);
                el.checked = gameConfig[key];
                el.onchange = (e) => {
                    gameConfig[key] = e.target.checked;
                };
            };
            
            const bindRealtimeSpeed = () => {
                 const el = document.getElementById('cfg-gameSpeed');
                 const valEl = document.getElementById('val-gameSpeed');
                 
                 el.value = gameSpeed;
                 valEl.innerText = gameSpeed.toFixed(1);

                 el.oninput = (e) => {
                     const val = parseFloat(e.target.value);
                     gameSpeed = val; 
                     valEl.innerText = val.toFixed(1);
                 };
            };

            bindRange('cfg-playerX', 'playerX');
            bindRange('cfg-gravity', 'gravity');
            bindRange('cfg-jump', 'jumpForce');
            bindRange('cfg-initSpeed', 'initialSpeed');
            bindRange('cfg-accel', 'speedIncrement');
            bindRange('cfg-gap', 'pipeGap');
            bindRange('cfg-dist', 'obstacleDistance');
            bindCheck('cfg-godMode', 'godMode');
            bindRealtimeSpeed();
        }
        
        function resetConfig() {
            if (currentMode === 'MOBILE') {
                gameConfig = { ...mobileConfig };
            } else {
                gameConfig = { ...pcConfig };
            }
            bindConfigUI();
            player.x = gameConfig.playerX;
            sound.score(); 
        }

        // --- 切换暂停状态 ---
        function togglePause() {
            if (gameState === 'PAUSED') {
                gameState = lastGameState;
                pauseScreen.style.display = 'none';
                pauseOverlay.style.display = 'none';
                if (gameState === 'MODE_SELECT' || gameState === 'START') {
                    startScreen.style.display = 'block';
                } else if (gameState === 'GAMEOVER') {
                    gameOverScreen.style.display = 'flex';
                } else if (gameState === 'PLAYING') {
                    scoreContainer.style.display = 'block';
                }
            } else {
                lastGameState = gameState;
                gameState = 'PAUSED';
                const speedEl = document.getElementById('cfg-gameSpeed');
                const speedVal = document.getElementById('val-gameSpeed');
                if(speedEl) {
                    speedEl.value = gameSpeed;
                    speedVal.innerText = gameSpeed.toFixed(1);
                }
                pauseScreen.style.display = 'flex';
                pauseOverlay.style.display = 'block';
                startScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                scoreContainer.style.display = 'none'; 
            }
        }

        // --- 音频系统 ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        const sound = {
            playTone: (freq, type, duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            jump: () => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(120, audioCtx.currentTime); 
                osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            },
            score: () => {
                sound.playTone(880, 'sine', 0.1, 0.1);
                setTimeout(() => sound.playTone(1760, 'sine', 0.2, 0.1), 50);
            },
            crash: () => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const bufferSize = audioCtx.sampleRate * 0.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                noise.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
            }
        };

        // --- 游戏对象 ---

        const particles = [];
        class Particle {
            constructor(x, y, color, speed, size) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size || Math.random() * 3 + 1;
                
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * speed; 
                
                this.vx = Math.cos(angle) * velocity;
                this.vy = Math.sin(angle) * velocity;
                
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.015; 
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.vy += 0.1; 
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.shadowBlur = 0; 
                ctx.globalAlpha = 1.0;
            }
        }

        const bgLayers = [
            { speed: 0.5, buildings: [], color: '#0a0a20', yOffset: 100 },
            { speed: 1.5, buildings: [], color: '#151530', yOffset: 50 },
            { speed: 3.0, buildings: [], color: '#202040', yOffset: 0 } 
        ];

        function initBackground() {
            bgLayers.forEach(layer => {
                layer.buildings = [];
                let currentX = 0;
                while (currentX < width + 200) {
                    const w = Math.random() * 50 + 30;
                    const h = Math.random() * (height / 2) + 50;
                    layer.buildings.push({ x: currentX, w: w, h: h });
                    currentX += w + Math.random() * 20 - 5; 
                }
            });
        }

        function updateBackground() {
            bgLayers.forEach(layer => {
                layer.buildings.forEach(b => {
                    b.x -= layer.speed * (gameState === 'PLAYING' ? 1 : 0.2); 
                });

                if (layer.buildings[0].x + layer.buildings[0].w < 0) {
                    layer.buildings.shift();
                    const lastB = layer.buildings[layer.buildings.length - 1];
                    const w = Math.random() * 50 + 30;
                    const h = Math.random() * (height / 2) + 50;
                    layer.buildings.push({ x: lastB.x + lastB.w + Math.random() * 20 - 5, w: w, h: h });
                }
            });
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#020205');
            gradient.addColorStop(1, '#1a0b2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const horizon = height * 0.8;
            for (let i = 0; i < width; i += 40) {
                let x = (i - time * 20) % width;
                if(x < 0) x += width;
                ctx.moveTo(x, height);
                ctx.lineTo((x - width/2) * 0.2 + width/2, horizon); 
            }
            for(let i=0; i< (height - horizon); i+=20) {
                 let y = height - i;
                 ctx.moveTo(0, y);
                 ctx.lineTo(width, y);
            }
            ctx.stroke();
            ctx.restore();

            bgLayers.forEach((layer, index) => {
                ctx.fillStyle = layer.color;
                layer.buildings.forEach(b => {
                    const renderY = height - b.h + layer.yOffset;
                    ctx.fillRect(b.x, renderY, b.w, b.h);
                    
                    if (index > 0) { 
                        ctx.globalAlpha = 0.5;
                        const seed = (b.x * b.w) % 100;
                        if (seed > 50) {
                            ctx.fillStyle = seed > 80 ? '#f0f' : '#0ff';
                            ctx.fillRect(b.x + 5, renderY + 10, 4, 4);
                        }
                        ctx.globalAlpha = 1.0;
                        ctx.fillStyle = layer.color; 
                    }
                });
            });
        }

        const player = {
            x: gameConfig.playerX,
            y: 150,
            radius: 12,
            velocity: 0,
            gravity: gameConfig.gravity, 
            jump: gameConfig.jumpForce,     
            maxFallSpeed: 8,
            rotation: 0,
            trail: [],
            currentTrailColor: '#00ffff', 
            
            update: function() {
                this.velocity += gameConfig.gravity; 
                
                if (this.velocity > this.maxFallSpeed) {
                    this.velocity = this.maxFallSpeed;
                }

                this.y += this.velocity;

                if (this.y + this.radius >= height) {
                    this.y = height - this.radius;
                    setGameOver();
                }
                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocity = 0; 
                }

                let targetRotation = 0;
                if (this.velocity < 0) targetRotation = -0.3;
                else targetRotation = 0.3;
                
                this.rotation += (targetRotation - this.rotation) * 0.1;

                if (frames % 3 === 0) {
                    this.trail.push({
                        x: this.x, 
                        y: this.y, 
                        alpha: 1,
                        color: this.currentTrailColor 
                    });
                    if (this.trail.length > 15) this.trail.shift(); 
                }
                this.trail.forEach(t => t.alpha -= 0.08);
            },

            draw: function() {
                ctx.save();
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                if (this.trail.length > 1) {
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const p1 = this.trail[i];
                        const p2 = this.trail[i+1];
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.strokeStyle = p1.color;
                        ctx.globalAlpha = p1.alpha;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = p1.color;
                        ctx.stroke();
                    }
                }
                ctx.restore();

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (gameConfig.godMode) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 8, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(time*10)*0.2})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                ctx.shadowBlur = 20;
                ctx.shadowColor = this.currentTrailColor; 
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(-10, 8);
                ctx.lineTo(-6, 0);
                ctx.lineTo(-10, -8);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = this.currentTrailColor; 
                ctx.shadowColor = this.currentTrailColor;
                ctx.beginPath();
                const flickr = Math.random() * 5;
                ctx.moveTo(-10, 0);
                ctx.lineTo(-18 - flickr, 4);
                ctx.lineTo(-18 - flickr, -4);
                ctx.fill();

                ctx.restore();
            },
            
            reset: function() {
                this.x = gameConfig.playerX;
                this.y = height / 2;
                this.velocity = 0;
                this.rotation = 0;
                this.trail = [];
                this.currentTrailColor = '#00ffff';
            },
            
            changeColor: function() {
                let newColor;
                do {
                    newColor = getRandomNeonColor();
                } while(newColor === this.currentTrailColor);
                this.currentTrailColor = newColor;
            }
        };

        const obstacles = [];
        const pipeWidth = 60;
        
        class Obstacle {
            constructor(prevTopHeight) {
                this.x = width;
                
                const gap = gameConfig.pipeGap; 
                const minH = 50;
                const maxH = height - gap - 50;

                if (prevTopHeight !== undefined) {
                    const maxDiff = height / 2;
                    const low = Math.max(minH, prevTopHeight - maxDiff);
                    const high = Math.min(maxH, prevTopHeight + maxDiff);
                    this.topHeight = Math.random() * (high - low) + low;
                } else {
                    this.topHeight = Math.random() * (maxH - minH) + minH;
                }
                
                this.bottomY = this.topHeight + gap;
                this.passed = false;
                this.markedForDeletion = false;
                this.color = getRandomNeonColor();
            }

            update() {
                this.x -= gameSpeed;
                if (this.x + pipeWidth < 0) this.markedForDeletion = true;

                if (!gameConfig.godMode) {
                    const padding = 6; 
                    
                    if (
                        player.x + player.radius - padding > this.x &&
                        player.x - player.radius + padding < this.x + pipeWidth &&
                        player.y - player.radius + padding < this.topHeight
                    ) {
                        setGameOver();
                    }

                    if (
                        player.x + player.radius - padding > this.x &&
                        player.x - player.radius + padding < this.x + pipeWidth &&
                        player.y + player.radius - padding > this.bottomY
                    ) {
                        setGameOver();
                    }
                }

                if (this.x + pipeWidth < player.x && !this.passed) {
                    score++;
                    scoreValEl.innerText = score.toString().padStart(3, '0');
                    scoreContainer.classList.add('score-active');
                    setTimeout(() => scoreContainer.classList.remove('score-active'), 100);
                    sound.score();
                    this.passed = true;
                    if (score % 5 === 0 && gameSpeed < 10) gameSpeed += gameConfig.speedIncrement;
                }
            }

            draw() {
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(this.x, 0, pipeWidth, this.topHeight);
                ctx.strokeRect(this.x, 0, pipeWidth, this.topHeight);
                ctx.fillRect(this.x, this.bottomY, pipeWidth, height - this.bottomY);
                ctx.strokeRect(this.x, this.bottomY, pipeWidth, height - this.bottomY);
                ctx.beginPath();
                ctx.moveTo(this.x + 10, 0);
                ctx.lineTo(this.x + 10, this.topHeight - 20);
                ctx.moveTo(this.x + pipeWidth - 10, this.bottomY + 20);
                ctx.lineTo(this.x + pipeWidth - 10, height);
                ctx.stroke();
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.topHeight - 10, pipeWidth, 10);
                ctx.fillRect(this.x, this.bottomY, pipeWidth, 10);
                ctx.shadowBlur = 0; 
            }
        }

        // --- 核心控制 ---

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if(gameState === 'MODE_SELECT' || gameState === 'START') initBackground();
        }

        // 返回标题画面
        function returnToTitle() {
            gameState = 'START';
            
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'block';
            
            // 切换面板显示
            modeSelectPanel.style.display = 'none';
            startPromptPanel.style.display = 'block';
            
            scoreContainer.style.display = 'block'; 
            scoreValEl.innerText = '000';
            
            player.reset();
            obstacles.length = 0;
            particles.length = 0;
            score = 0;
            gameSpeed = gameConfig.initialSpeed;
        }

        // 重置并开始游戏
        function resetGame() {
            player.reset();
            obstacles.length = 0;
            particles.length = 0;
            score = 0;
            scoreValEl.innerText = '000'; 
            gameSpeed = gameConfig.initialSpeed; 
            frames = 0;
            
            gameState = 'PLAYING';
            
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            pauseOverlay.style.display = 'none';
            scoreContainer.style.display = 'block';
            
            player.velocity = -gameConfig.jumpForce; 
            sound.jump();
        }

        // 生成死亡粒子效果
        function setGameOver() {
            if (gameState === 'GAMEOVER') return;
            if (gameConfig.godMode) return;

            gameState = 'GAMEOVER';
            sound.crash();
            
            for(let i=0; i<100; i++) { 
                const color = getRandomNeonColor();
                const speed = Math.random() * 12 + 8; 
                const size = Math.random() * 5 + 2;
                particles.push(new Particle(player.x, player.y, color, speed, size));
            }
            
            setTimeout(() => {
                finalScoreEl.innerText = `最终得分: ${score.toString().padStart(3, '0')}`;
                gameOverScreen.style.display = 'flex'; 
            }, 500);
        }

        // UI点击事件处理
        function handleInput(e) {
            // 阻止 UI 元素点击事件被拦截
            if (e.target.closest('#settings-btn') || 
                e.target.closest('button') || 
                e.target.closest('input') ||
                e.target.closest('.mode-btn') ||
                e.target.closest('.cyber-link') || 
                e.target.closest('#pause-screen')) {
                return;
            }

            if (e.type === 'keydown' && e.code === 'Escape') {
                togglePause();
                return;
            }
            if (gameState === 'PAUSED' || gameState === 'MODE_SELECT') return;

            if (e.type === 'keydown' && e.code !== 'Space') return;
            if (e.type === 'touchstart') e.preventDefault(); 

            // START 状态下点击开始游戏
            if (gameState === 'START') {
                resetGame();
                return;
            }

            if (gameState === 'PLAYING') {
                player.velocity = -gameConfig.jumpForce; 
                player.changeColor(); 
                sound.jump();
                
                for(let i=0; i<5; i++) {
                    particles.push(new Particle(player.x - 10, player.y, player.currentTrailColor, 2));
                }
            }
        }
        
        restartBtn.addEventListener('mousemove', (e) => {
             if (Math.random() > 0.5) return;
             const x = e.clientX;
             const y = e.clientY;
             for(let i=0; i<2; i++) {
                const color = getRandomNeonColor();
                particles.push(new Particle(x, y, color, 4, Math.random() * 3 + 1));
             }
        });

        // --- 游戏循环 ---

        function update() {
            if (gameState === 'PAUSED') return;

            time += 0.05;
            frames++;
            
            updateBackground();
            
            if (gameState === 'PLAYING') {
                player.update();
                
                // 障碍物生成逻辑
                const lastOb = obstacles.length > 0 ? obstacles[obstacles.length - 1] : null;
                
                if (!lastOb || (width - lastOb.x >= gameConfig.obstacleDistance)) {
                    const prevH = lastOb ? lastOb.topHeight : undefined;
                    obstacles.push(new Obstacle(prevH));
                }

                obstacles.forEach((ob, index) => {
                    ob.update();
                    if (ob.markedForDeletion) {
                        obstacles.splice(index, 1);
                    }
                });
            } else if (gameState === 'GAMEOVER') {
                 if (player.y < height - player.radius) {
                     player.y += 10;
                     player.rotation += 0.2;
                 }
            } else if (gameState === 'START') {
                // 更新悬浮动画位置
                player.y = height / 2 + Math.sin(time * 2) * 20;
            } else if (gameState === 'MODE_SELECT') {
                // 更新背景飞机位置
                player.y = height / 2 + Math.sin(time * 2) * 20;
            }

            particles.forEach((p, index) => {
                p.update();
                if (p.life <= 0) particles.splice(index, 1);
            });
        }

        function draw() {
            if (gameState === 'PAUSED') return; 

            // 1. 绘制背景和拖尾层
            ctx.fillStyle = 'rgba(5, 5, 16, 0.6)'; 
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            // 屏幕震动
            if (gameState === 'GAMEOVER' && Math.random() > 0.8) {
                const shake = 5;
                ctx.translate(Math.random()*shake - shake/2, Math.random()*shake - shake/2);
            }

            // 2. 绘制场景元素
            drawBackground();
            
            obstacles.forEach(ob => ob.draw());
            particles.forEach(p => p.draw());
            
            // 绘制玩家
            player.draw();

            ctx.restore();
            
            // 后期处理效果
            if (Math.random() > 0.98 || gameState === 'GAMEOVER') {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.05;
                ctx.drawImage(canvas, -5, 0); 
                ctx.drawImage(canvas, 5, 0);  
                ctx.restore();
            }
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        window.addEventListener('resize', resize);
        window.addEventListener('keydown', handleInput);
        window.addEventListener('touchstart', handleInput, {passive: false});
        window.addEventListener('mousedown', handleInput);

        // 初始化配置
        bindConfigUI();
        resize();
        initBackground();
        loop(); 

    </script>
</body>
</html>